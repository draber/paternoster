/// Add url() or linear-gradient to an image/shadow if required
/// linear-gradient is a blatant assumption of course
/// @param {String} $resource image or shadow data with or without url/gradient
/// @return {String} $resource wrapped in the correct function
@function urlify($resource, $type) {
	@if ($type == 'image') {
		@if (str-index($resource, 'url') == null) {
			@return 'url(#{$resource})';
		} @else {
			@return $resource;
		}
	} @else if ($type == 'shadow') {
		@if (str-index($resource, 'gradient') == null) {
			@return 'linear-gradient(#{$resource})';
		} @else {
			@return $resource;
		}
	}
	@return $resource;
}

/// Convenience function to find elements that are void in this context
/// @param {String} $resource
/// @return {Boolean}
@function notIsEmpty($resource) {
	@return $resource != '' and $resource != false and $resource != null;
}


/// Pluralize the type of layer
/// @param {String} $type image|shadow
/// @return {String} $type images|shadows
@function typeToPlural($type) {
	@return map-get((
		image: 'images',
		shadow: 'shadows'
	), $type);
}


/// Get the shorthand either images or shadows
/// @param {Map} $panel
/// @param {String} $type image|shadow
/// @return {String} $shorthand
@function getFragmentByType($panel, $type) {

	$orderedKeys: (
		'repeat',
		'position',
		'size',
		'attachment',
		'origin',
		'clip'
	);

	$shorthand: '';
	$items: ();

	// single entity takes precedence over a multiple of the same
	$single: map-get($panel, $type);
	$multiple: map-get($panel, typeToPlural($type));
	// create an image/shadow map from a single resource
	@if (notIsEmpty($single)) {
		$multiple: ();
		$singleMap: (resource: $single);
		@each $key in $orderedKeys {
			$value: (#{$key}: map-get($panel, $key));
			$singleMap: map-merge($singleMap, $value);
		}
		$multiple: append($multiple, $singleMap);
	}

	@if (notIsEmpty($multiple)) {
		@each $dataSet in $multiple {
			$resource: map-get($dataSet, 'resource');
			@if(notIsEmpty($resource)) {
				$resource: urlify($resource, $type);

				$position: map-get($dataSet, 'position');
				$size: map-get($dataSet, 'size');
				@if(notIsEmpty($size) and $position == ''){
					$position: '0 0';
				}
				@if (notIsEmpty($position) and notIsEmpty($size)) {
					$dataSet: map-merge($dataSet, (position: $position + ' /'));
				}
				@each $key in $orderedKeys {
					$value: map-get($dataSet, $key);
					@if (notIsEmpty($value)) {
						$resource: $resource + ' ' + $value;
					}
				}

				$items: append($items, $resource);
			}
		}
	}

	@if (length($items) != 0) {
		$shorthand: list-implode(', ', $items);
	}

	@return $shorthand;
}


/// Setup a panel
/// @param {Map} $panel
/// @param {String} $type image|shadow
/// @return {String} $shorthand
@function getShorthand($panel, $type) {

	// Is there a shorthand already?
	$shorthand: map-get($panel, 'shorthand');
	@if (notIsEmpty($shorthand)) {
		@return $shorthand;
	}

	$shorthand: map-get($panel, 'color');

	$fragment: getFragmentByType($panel, $type);
	@if (notIsEmpty($fragment)) {
		$shorthand: $shorthand + ' ' + $fragment;
	}

	@return $shorthand;
}


/// Generate background value based on configuration
/// @param {String} $side top|right|bottom|left|back|front|cage-frame|top-frame|bottom-frame
/// @param {String} $type image|shadow
@mixin background($side, $type) {

	$typePlural: typeToPlural($type);

	// get the right layer
	$panel: map-get($defaultPanels, $typePlural);
	$panel: map-get($panel, $side);

	// merge custom panel
	@if (map-has-key($customPanels, $typePlural)) {
		$customPanels: map-get($customPanels, $typePlural);
		@if (map-has-key($customPanels, $side)) {
			$panel: map-merge($panel, map-get($customPanels, $side));
		}
	}

	// merge default panel on skeleton
	$panel: map-merge($panelSkeleton, $panel);

	$shorthand: getShorthand($panel, $type);
	background: #{$shorthand};
}
